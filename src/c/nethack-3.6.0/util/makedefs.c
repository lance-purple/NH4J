/* NetHack 3.6  makedefs.c  $NHDT-Date: 1447062431 2015/11/09 09:47:11 $  $NHDT-Branch: master $:$NHDT-Revision: 1.105 $ */
/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
/* Copyright (c) M. Stephenson, 1990, 1991.                       */
/* Copyright (c) Dean Luick, 1990.                                */
/* NetHack may be freely redistributed.  See license for details. */

#define MAKEDEFS_C /* use to conditionally include file sections */

#include "config.h"

#include "permonst.h"
#include "objclass.h"
#include "monsym.h"
#include "artilist.h"
#include "dungeon.h"
#include "obj.h"
#include "monst.h"
#include "you.h"
#include "context.h"
#include "flag.h"
#include "dlb.h"

/* version information */
#include "patchlevel.h"

#include <ctype.h>

#define SpinCursor(x)

#define Fprintf (void) fprintf
#define Fclose (void) fclose
#define Unlink (void) unlink
#define rewind(fp) fseek((fp), 0L, SEEK_SET) /* guarantee a return value */

static const char SCCS_Id[] = "@(#)makedefs.c\t3.5\t2004/02/01";


/* names of files to be generated */
#define DATE_FILE "date.h"
#define MONST_FILE "pm.h"
#define ONAME_FILE "onames.h"

#define OPTIONS_FILE "options"

#define ORACLE_FILE "oracles"
#define DATA_FILE "data"
#define RUMOR_FILE "rumors"
#define DGN_I_FILE "dungeon.def"
#define DGN_O_FILE "dungeon.pdf"
#define MON_STR_C "monstr.c"
#define QTXT_I_FILE "quest.txt"
#define QTXT_O_FILE "quest.dat"
#define VIS_TAB_H "vis_tab.h"
#define VIS_TAB_C "vis_tab.c"
/* locations for those files */

#define INCLUDE_TEMPLATE "../include/%s"
#define SOURCE_TEMPLATE "../src/%s"
#define DGN_TEMPLATE "../dat/%s" /* where dungeon.pdf file goes */
#define DATA_TEMPLATE "../dat/%s"
#define DATA_IN_TEMPLATE "../dat/%s"

static const char
    *Dont_Edit_Code =
        "/* This source file is generated by 'makedefs'.  Do not edit. */\n",
    *Dont_Edit_Data =
        "#\tThis data file is generated by 'makedefs'.  Do not edit. \n";

static struct version_info version;

/* definitions used for vision tables */
#define TEST_WIDTH COLNO
#define TEST_HEIGHT ROWNO
#define BLOCK_WIDTH (TEST_WIDTH + 10)
#define BLOCK_HEIGHT TEST_HEIGHT /* don't need extra spaces */
#define MAX_ROW (BLOCK_HEIGHT + TEST_HEIGHT)
#define MAX_COL (BLOCK_WIDTH + TEST_WIDTH)
/* Use this as an out-of-bound value in the close table.  */
#define CLOSE_OFF_TABLE_STRING "99" /* for the close table */
#define FAR_OFF_TABLE_STRING "0xff" /* for the far table */

#define sign(z) ((z) < 0 ? -1 : ((z) ? 1 : 0))

/*-end of vision defs-*/

static char filename[600];

int FDECL(main, (int, char **));
void FDECL(do_makedefs, (char *));
void NDECL(do_objs);
void NDECL(do_data);
void NDECL(do_dungeon);
void NDECL(do_date);
void NDECL(do_options);
void NDECL(do_questtxt);
void NDECL(do_rumors);
void NDECL(do_oracles);
void NDECL(do_vision);

extern void NDECL(monst_init);   /* monst.c */
extern void NDECL(objects_init); /* objects.c */

static void NDECL(make_version);
static char *FDECL(version_string, (char *, const char *));
static char *FDECL(version_id_string, (char *, const char *));
static char *FDECL(bannerc_string, (char *, const char *));
static char *FDECL(xcrypt, (const char *));
static unsigned long FDECL(read_rumors_file,
                           (const char *, int *, long *, unsigned long));
static void FDECL(do_rnd_access_file, (const char *));
static boolean FDECL(d_filter, (char *));
static boolean FDECL(h_filter, (char *));
static boolean FDECL(ranged_attk, (struct permonst *));
static void NDECL(build_savebones_compat_string);
static void FDECL(do_ext_makedefs, (int, char **));
static void NDECL(windowing_sanity);

static boolean FDECL(qt_comment, (char *));
static boolean FDECL(qt_control, (char *));
static int FDECL(get_hdr, (char *));
static boolean FDECL(new_id, (char *));
static boolean FDECL(known_msg, (int, int));
static void FDECL(new_msg, (char *, int, int));
static char *FDECL(valid_qt_summary, (char *, BOOLEAN_P));
static void FDECL(do_qt_control, (char *));
static void FDECL(do_qt_text, (char *));
static void NDECL(adjust_qt_hdrs);
static void NDECL(put_qt_hdrs);

static char *FDECL(fgetline, (FILE*));
static char *FDECL(tmpdup, (const char *));
static char *FDECL(limit, (char *, int));
static char *FDECL(eos, (char *));

/* input, output, tmp */
static FILE *ifp, *ofp, *tfp;

int
main(argc, argv)
int argc;
char *argv[];
{
    do_makedefs(&argv[1][1]);
}

static void
link_sanity_check()
{
    /* Note:  these initializers don't do anything except guarantee that
            we're linked properly.
    */
    monst_init();
    objects_init();
}

void
do_makedefs(options)
char *options;
{
    link_sanity_check();

    /* construct the current version number */
    make_version();

    switch (*options) {
        case 'd':
        case 'D':
            do_data();
            break;
        case 'e':
        case 'E':
            do_dungeon();
            break;
        case 'v':
        case 'V':
            do_date();
            do_options();
            break;
        case 'q':
        case 'Q':
            do_questtxt();
            break;
        case 'r':
        case 'R':
            do_rumors();
            break;
        case 's':
        case 'S':
            do_rnd_access_file(EPITAPHFILE);
            do_rnd_access_file(ENGRAVEFILE);
            do_rnd_access_file(BOGUSMONFILE);
            break;
        case 'h':
        case 'H':
            do_oracles();
            break;

        default:
            Fprintf(stderr, "Unknown option '%c'.\n", *options);
            (void) fflush(stderr);
            exit(EXIT_FAILURE);
    }
}

static char namebuf[1000];
static char *
name_file(template, tag)
char *template;
char *tag;
{
    Sprintf(namebuf, template, tag);
    return namebuf;
}

static void
delete_file(template, tag)
char *template;
char *tag;
{
    char *name = name_file(template, tag);
    Unlink(name);
}

static FILE *
getfp(template, tag, mode)
char *template;
char *tag;
char *mode;
{
    char *name = name_file(template, tag);
    FILE *rv = fopen(name, mode);
    if (!rv) {
        Fprintf(stderr, "Can't open '%s'.\n", name);
        exit(EXIT_FAILURE);
    }
    return rv;
}

static boolean debug = FALSE;

static FILE *inputfp;
static FILE *outputfp;

struct grep_var {
    const char *name;
    int is_defined; /* 0 undef; 1 defined */
};
/* struct grep_var grep_vars[] and TODO_* constants in include file: */
#include "mdgrep.h"

static void NDECL(do_grep);
static struct grep_var *FDECL(grepsearch, (char *));
static int grep_trace = 0;

/*
 Filtering syntax:
 Any line NOT starting with a caret is either suppressed or passed through
 unchanged depending on the current conditional state.

 The default conditional state is printing on.

 Conditionals may be nested.

 makedefs will exit with a EXIT_FAILURE if any errors are detected; as many
 errors as possible are detected before giving up.

 Unknown identifiers are treated as TRUE and also as an error to allow
 processing to continue past the unknown identifier (note that "#undef" is
 different than unknown).

 Any line starting with a caret is a control line; as in C, zero or more
 spaces
 may be embedded in the line almost anywhere; the caret MUST be in column 1.
 (XXX for the moment, no white space is allowed after the caret because
  existing lines in the docs look like that)

 Control lines:
 ^^     a line starting with a (single) literal caret
 ^#     a comment - the line is ignored
 ^?ID   if defined(ID)
 ^!ID   if !defined(ID)
 ^:     else
 ^.     endif

*/
#define GREP_MAGIC '^'
#define GREP_STACK_SIZE 100
static int grep_writing = 1; /* need to copy lines to output */
static int grep_errors = 0;
static int grep_sp = 0;
#define ST_LD(old, opp) (!!(old) | (!!(opp) << 1))
#define ST_OLD(v) ((v) &1)
#define ST_OPP(v) !!((v) &2)
#define ST_ELSE 4
static int grep_stack[GREP_STACK_SIZE] = { ST_LD(1, 0) };
static int grep_lineno = 0;


static struct grep_var *
grepsearch(name)
char *name;
{
    /* XXX make into binary search */
    int x = 0;
    while (x < SIZE(grep_vars) - 1) {
        if (!strcmp(grep_vars[x].name, name))
            return &grep_vars[x];
        x++;
    }
    return 0;
}

static int
grep_check_id(id)
char *id;
{
    struct grep_var *rv;
    while (*id && isspace(*id))
        id++;
    if (!*id) {
        Fprintf(stderr, "missing identifier in line %d", grep_lineno);
        grep_errors++;
        return 0;
    }
    rv = grepsearch(id);
    if (rv) {
        if (grep_trace) {
            Fprintf(outputfp, "ID %d %s\n", rv->is_defined, id);
        }
        return rv->is_defined;
    }

    if (grep_trace) {
        Fprintf(outputfp, "ID U %s\n", id);
    }
    Fprintf(stderr, "unknown identifier '%s' in line %d.\n", id, grep_lineno);
    grep_errors++;
    return 2; /* So new features can be checked before makedefs
               * is rebuilt. */
}

static void
grep_show_wstack(tag)
char *tag;
{
    int x;

    if (!grep_trace)
        return;

    Fprintf(outputfp, "%s w=%d sp=%d\t", tag, grep_writing, grep_sp);
    for (x = grep_sp; x >= 0 && x > grep_sp - 6; x--) {
        Fprintf(outputfp, "[%d]=%d ", x, grep_stack[x]);
    }
    Fprintf(outputfp, "\n");
}

static char *
do_grep_control(buf)
char *buf;
{
    int isif = 1;
    char *buf0 = buf;
    if (isspace(buf[0]))
        return &buf[-1]; /* XXX see docs above */
    switch (buf[0]) {
    case '#': /* comment */
        break;
    case '.': /* end of if level */
        if (grep_sp == 0) {
            Fprintf(stderr, "unmatched ^. (endif) at line %d.\n",
                    grep_lineno);
            grep_errors++;
        } else {
            grep_writing = ST_OLD(grep_stack[grep_sp--]);
            grep_show_wstack("pop");
        }
        break;
    case '!': /* if not ID */
        isif = 0;
    /* FALLTHROUGH */
    case '?': /* if ID */
        if (grep_sp == GREP_STACK_SIZE - 2) {
            Fprintf(stderr, "stack overflow at line %d.", grep_lineno);
            exit(EXIT_FAILURE);
        }
        if (grep_writing) {
            isif = grep_check_id(&buf[1]) ? isif : !isif;
            grep_stack[++grep_sp] = ST_LD(grep_writing, !isif);
            grep_writing = isif;
        } else {
            grep_stack[++grep_sp] = ST_LD(0, 0);
            /* grep_writing = 0; */
        }
        grep_show_wstack("push");
        break;
    case ':': /* else */
        if (ST_ELSE & grep_stack[grep_sp]) {
            Fprintf(stderr, "multiple : for same conditional at line %d.\n",
                    grep_lineno);
            grep_errors++;
        }
        grep_writing = ST_OPP(grep_stack[grep_sp]);
        grep_stack[grep_sp] |= ST_ELSE;
        break;
    case GREP_MAGIC: /* ^^ -> ^ */
        return buf0;
    default: {
        char str[10];
        if (isprint(buf[0])) {
            str[0] = buf[0];
            str[1] = '\0';
        } else {
            sprintf(str, "0x%02x", buf[0]);
        }
        Fprintf(stderr, "unknown control ^%s at line %d.\n", str,
                grep_lineno);
        grep_errors++;
    } break;
    }
    return NULL;
}

static void grep0(FILE *, FILE *);

static void
do_grep()
{
    if (!inputfp) {
        Fprintf(stderr, "--grep requires --input\n");
    }
    if (!outputfp) {
        Fprintf(stderr, "--grep requires --output\n");
    }
    if (!inputfp || !outputfp) {
        exit(EXIT_FAILURE);
    }

    grep0(inputfp, outputfp);
}

static void
grep0(inputfp0, outputfp0)
FILE *inputfp0;
FILE *outputfp0;
{
    char buf[16384]; /* looong, just in case */

    while (!feof(inputfp0) && !ferror(inputfp0)) {
        char *tmp;
        char *buf1;

        if (fgets(buf, sizeof(buf), inputfp0) == 0)
            break;
        if ((tmp = strchr(buf, '\n')))
            *tmp = '\0';
        grep_lineno++;
        if (grep_trace) {
            Fprintf(outputfp0, "%04d %c >%s\n", grep_lineno,
                    grep_writing ? ' ' : '#', buf);
        }

        if (buf[0] == GREP_MAGIC) {
            buf1 = do_grep_control(&buf[1]);
            if (!buf1)
                continue;
        } else {
            buf1 = buf;
        }
        if (grep_writing)
            Fprintf(outputfp0, "%s\n", buf1);
    }
    if (ferror(inputfp0)) {
        Fprintf(stderr, "read error!\n");
        exit(EXIT_FAILURE);
    }
    if (ferror(outputfp0)) {
        Fprintf(stderr, "write error!\n");
        exit(EXIT_FAILURE);
    }
    fclose(inputfp0);
    fclose(outputfp0);
    if (grep_sp) {
        Fprintf(stderr, "%d unterminated conditional level%s\n", grep_sp,
                grep_sp == 1 ? "" : "s");
        grep_errors++;
    }
    if (grep_errors) {
        Fprintf(stderr, "%d error%s detected.\n", grep_errors,
                grep_errors == 1 ? "" : "s");
        exit(EXIT_FAILURE);
    }
}

/* trivial text encryption routine which can't be broken with `tr' */
static char *
xcrypt(str)
const char *str;
{ /* duplicated in src/hacklib.c */
    static char buf[BUFSZ];
    register const char *p;
    register char *q;
    register int bitmask;

    for (bitmask = 1, p = str, q = buf; *p; q++) {
        *q = *p++;
        if (*q & (32 | 64))
            *q ^= bitmask;
        if ((bitmask <<= 1) >= 32)
            bitmask = 1;
    }
    *q = '\0';
    return buf;
}

#define PAD_RUMORS_TO 60
/* common code for do_rumors().  Return 0 on error. */
static unsigned long
read_rumors_file(file_ext, rumor_count, rumor_size, old_rumor_offset)
const char *file_ext;
int *rumor_count;
long *rumor_size;
unsigned long old_rumor_offset;
{
    char infile[600];
    char *line;
    unsigned long rumor_offset;

    Sprintf(infile, DATA_IN_TEMPLATE, RUMOR_FILE);
    Strcat(infile, file_ext);
    if (!(ifp = fopen(infile, RDTMODE))) {
        perror(infile);
        return 0L;
    }

    /* copy the rumors */
    while ((line = fgetline(ifp)) != 0) {

        /* rumor selection is accomplished by seeking to a random
           position in the file, advancing to newline, and taking
           the next line; therefore, rumors which follow long-line
           rumors are most likely to be chosen and rumors which
           follow short-line rumors are least likely to be chosen;
           we ameliorate the latter by padding the shortest lines,
           increasing the chance of the random seek landing in them */
        int len = (int) strlen(line);

        if (len <= PAD_RUMORS_TO) {
            char *base = index(line, '\n');
            /* this is only safe because fgetline() overallocates */
            while (len++ < PAD_RUMORS_TO) {
                *base++ = '_';
            }
            *base++ = '\n';
            *base = '\0';
        }

        (*rumor_count)++;
        (void) fputs(xcrypt(line), tfp);
        free(line);
    }
    /* record the current position; next rumors section will start here */
    rumor_offset = (unsigned long) ftell(tfp);
    Fclose(ifp); /* all done with rumors.file_ext */

    /* the calculated value for *_rumor_count assumes that
       a single-byte line terminator is in use; for platforms
       which use two byte CR+LF, we need to override that value
       [it's much simpler to do so unconditionally, rendering
       the loop's accumulation above obsolete] */
    *rumor_size = (long) (rumor_offset - old_rumor_offset);
    return rumor_offset;
}

void
do_rnd_access_file(fname)
const char *fname;
{
    char *line;

    Sprintf(filename, DATA_IN_TEMPLATE, fname);
    Strcat(filename, ".txt");
    if (!(ifp = fopen(filename, RDTMODE))) {
        perror(filename);
        exit(EXIT_FAILURE);
    }
    filename[0] = '\0';
    Sprintf(eos(filename), DATA_TEMPLATE, fname);
    if (!(ofp = fopen(filename, WRTMODE))) {
        perror(filename);
        exit(EXIT_FAILURE);
    }
    Fprintf(ofp, "%s", Dont_Edit_Data);

    tfp = getfp(DATA_TEMPLATE, "grep.tmp", WRTMODE);
    grep0(ifp, tfp);
    ifp = getfp(DATA_TEMPLATE, "grep.tmp", RDTMODE);

    while ((line = fgetline(ifp)) != 0) {
        if (line[0] != '#' && line[0] != '\n')
            (void) fputs(xcrypt(line), ofp);
        free(line);
    }
    Fclose(ifp);
    Fclose(ofp);

    delete_file(DATA_TEMPLATE, "grep.tmp");
    return;
}

void
do_rumors()
{
    char *line;
    static const char rumors_header[] =
        "%s%04d,%06ld,%06lx;%04d,%06ld,%06lx;0,0,%06lx\n";
    char tempfile[600];
    int true_rumor_count, false_rumor_count;
    long true_rumor_size, false_rumor_size;
    unsigned long true_rumor_offset, false_rumor_offset, eof_offset;

    Sprintf(tempfile, DATA_TEMPLATE, "rumors.tmp");
    filename[0] = '\0';
    Sprintf(eos(filename), DATA_TEMPLATE, RUMOR_FILE);
    if (!(ofp = fopen(filename, WRTMODE))) {
        perror(filename);
        exit(EXIT_FAILURE);
    }
    if (!(tfp = fopen(tempfile, WRTMODE))) {
        perror(tempfile);
        Fclose(ofp);
        exit(EXIT_FAILURE);
    }

    true_rumor_count = false_rumor_count = 0;
    true_rumor_size = false_rumor_size = 0L;
    true_rumor_offset = false_rumor_offset = eof_offset = 0L;

    /* output a dummy header record; we'll replace it in final output */
    Fprintf(tfp, rumors_header, Dont_Edit_Data, true_rumor_count,
            true_rumor_size, true_rumor_offset, false_rumor_count,
            false_rumor_size, false_rumor_offset, eof_offset);
    /* record the current position; true rumors will start here */
    true_rumor_offset = ftell(tfp);

    false_rumor_offset = read_rumors_file(
        ".tru", &true_rumor_count, &true_rumor_size, true_rumor_offset);
    if (!false_rumor_offset)
        goto rumors_failure;

    eof_offset = read_rumors_file(".fal", &false_rumor_count,
                                  &false_rumor_size, false_rumor_offset);
    if (!eof_offset)
        goto rumors_failure;

    /* get ready to transfer the contents of temp file to output file */
    line = malloc(256);
    Sprintf(line, "rewind of \"%s\"", tempfile);
    if (rewind(tfp) != 0) {
        perror(line);
        free(line);
        goto rumors_failure;
    }
    free(line);

    /* output the header record */
    Fprintf(ofp, rumors_header, Dont_Edit_Data, true_rumor_count,
            true_rumor_size, true_rumor_offset, false_rumor_count,
            false_rumor_size, false_rumor_offset, eof_offset);
    /* skip the temp file's dummy header */
    if (!(line = fgetline(tfp))) { /* "Don't Edit" */
        perror(tempfile);
        goto rumors_failure;
    }
    free(line);
    if (!(line = fgetline(tfp))) { /* count,size,offset */
        perror(tempfile);
        goto rumors_failure;
    }
    free(line);
    /* copy the rest of the temp file into the final output file */
    while ((line = fgetline(tfp)) != 0) {
        (void) fputs(line, ofp);
        free(line);
    }
    /* all done; delete temp file */
    Fclose(tfp);
    Unlink(tempfile);
    Fclose(ofp);
    return;

rumors_failure:
    Fclose(ofp);
    Unlink(filename); /* kill empty or incomplete output file */
    Fclose(tfp);
    Unlink(tempfile); /* and temporary file */
    exit(EXIT_FAILURE);
}

/*
 * Use this to explicitly mask out features during version checks.
 *
 * ZEROCOMP, RLECOMP, and ZLIB_COMP describe compression features
 * that the port/plaform which wrote the savefile was capable of
 * dealing with. Don't reject a savefile just because the port
 * reading the savefile doesn't match on all/some of them.
 * The actual compression features used to produce the savefile are
 * recorded in the savefile_info structure immediately following the
 * version_info, and that is what needs to be checked against the
 * feature set of the port that is reading the savefile back in.
 * That check is done in src/restore.c now.
 *
 */
#define IGNORED_FEATURES                 \
    (0L | (1L << 19) /* SCORE_ON_BOTL */ \
     | (1L << 27)    /* ZEROCOMP */      \
     | (1L << 28)    /* RLECOMP */       \
     )

static void
make_version()
{
    register int i;

    /*
     * integer version number
     */
    version.incarnation = ((unsigned long) VERSION_MAJOR << 24)
                          | ((unsigned long) VERSION_MINOR << 16)
                          | ((unsigned long) PATCHLEVEL << 8)
                          | ((unsigned long) EDITLEVEL);
    /*
     * encoded feature list
     * Note:  if any of these magic numbers are changed or reassigned,
     * EDITLEVEL in patchlevel.h should be incremented at the same time.
     * The actual values have no special meaning, and the category
     * groupings are just for convenience.
     */
    version.feature_set = (unsigned long) (0L
/* levels and/or topology (0..4) */
/* monsters (5..9) */

/* objects (10..14) */
/* flag bits and/or other global variables (15..26) */

                                           | (1L << 17)

                                           | (1L << 18)

/* data format (27..31)
 * External compression methods such as COMPRESS and ZLIB_COMP
 * do not affect the contents and are thus excluded from here */

                                               );
    /*
     * Value used for object & monster sanity check.
     *    (NROFARTIFACTS<<24) | (NUM_OBJECTS<<12) | (NUMMONS<<0)
     */
    for (i = 1; artifact_names[i]; i++)
        continue;
    version.entity_count = (unsigned long) (i - 1);
    for (i = 1; objects[i].oc_class != ILLOBJ_CLASS; i++)
        continue;
    version.entity_count = (version.entity_count << 12) | (unsigned long) i;

    int monster_count = 0;
    sscanf(getenv("MONSTER_COUNT"), "%d", &monster_count);
    i += monster_count;

    version.entity_count = (version.entity_count << 12) | (unsigned long) i;
    /*
     * Value used for compiler (word size/field alignment/padding) check.
     */
    version.struct_sizes1 =
        (((unsigned long) sizeof(struct context_info) << 24)
         | ((unsigned long) sizeof(struct obj) << 17)
         | ((unsigned long) sizeof(struct monst) << 10)
         | ((unsigned long) sizeof(struct you)));
    version.struct_sizes2 = (((unsigned long) sizeof(struct flag) << 10) |
/* free bits in here */
                             ((unsigned long) 0L));
    return;
}

static char *
version_string(outbuf, delim)
char *outbuf;
const char *delim;
{
    Sprintf(outbuf, "%d%s%d%s%d", VERSION_MAJOR, delim, VERSION_MINOR, delim,
            PATCHLEVEL);
    return outbuf;
}

static char *
version_id_string(outbuf, build_date)
char *outbuf;
const char *build_date;
{
    char subbuf[64], versbuf[64];

    subbuf[0] = '\0';

    Sprintf(outbuf, "%s NetHack%s Version %s - last build %s.", PORT_ID,
            subbuf, version_string(versbuf, "."), build_date);
    return outbuf;
}

static char *
bannerc_string(outbuf, build_date)
char *outbuf;
const char *build_date;
{
    char subbuf[64], versbuf[64];

    subbuf[0] = '\0';

    Sprintf(outbuf, "         Version %s %s%s, built %s.",
            version_string(versbuf, "."), PORT_ID, subbuf, &build_date[4]);
    return outbuf;
}

void
do_date()
{
    time_t clocktim = 0;
    char *c, cbuf[60], buf[BUFSZ];
    const char *ul_sfx;

    /* before creating date.h, make sure that xxx_GRAPHICS and
       DEFAULT_WINDOW_SYS have been set up in a viable fashion */
    windowing_sanity();

    filename[0] = '\0';
    Sprintf(eos(filename), INCLUDE_TEMPLATE, DATE_FILE);
    if (!(ofp = fopen(filename, WRTMODE))) {
        perror(filename);
        exit(EXIT_FAILURE);
    }
    /* NB: We've moved on from SCCS, but this way this line
     * won't get clobbered when downstream projects import
     * this file into something more modern. */
    Fprintf(ofp, "%s", Dont_Edit_Code);

    (void) time(&clocktim);
    Strcpy(cbuf, ctime(&clocktim));

    for (c = cbuf; *c; c++)
        if (*c == '\n')
            break;
    *c = '\0'; /* strip off the '\n' */
    Fprintf(ofp, "#define BUILD_DATE \"%s\"\n", cbuf);
    Fprintf(ofp, "#define BUILD_TIME (%ldL)\n", (long) clocktim);
    Fprintf(ofp, "\n");
    ul_sfx = "UL";

    Fprintf(ofp, "#define VERSION_NUMBER 0x%08lx%s\n", version.incarnation,
            ul_sfx);
    Fprintf(ofp, "#define VERSION_FEATURES 0x%08lx%s\n", version.feature_set,
            ul_sfx);

    Fprintf(ofp, "#define IGNORED_FEATURES 0x%08lx%s\n",
            (unsigned long) IGNORED_FEATURES, ul_sfx);

    Fprintf(ofp, "#define VERSION_SANITY1 0x%08lx%s\n", version.entity_count,
            ul_sfx);
    Fprintf(ofp, "#define VERSION_SANITY2 0x%08lx%s\n", version.struct_sizes1,
            ul_sfx);
    Fprintf(ofp, "#define VERSION_SANITY3 0x%08lx%s\n", version.struct_sizes2,
            ul_sfx);
    Fprintf(ofp, "\n");
    Fprintf(ofp, "#define VERSION_STRING \"%s\"\n", version_string(buf, "."));
    Fprintf(ofp, "#define VERSION_ID \\\n \"%s\"\n",
            version_id_string(buf, cbuf));
    Fprintf(ofp, "#define COPYRIGHT_BANNER_C \\\n \"%s\"\n",
            bannerc_string(buf, cbuf));
    Fprintf(ofp, "\n");
    Fclose(ofp);
    return;
}

static char save_bones_compat_buf[BUFSZ];

static void
build_savebones_compat_string()
{
    Strcpy(save_bones_compat_buf,
           "save and bones files accepted from version");
    Sprintf(eos(save_bones_compat_buf), " %d.%d.%d only", VERSION_MAJOR,
            VERSION_MINOR, PATCHLEVEL);
}

static const char *build_opts[] = {
    "color",
    "data file compression",
    "insurance files for recovering from crashes",
    "exclusive lock on level 0 file",
    "log file",
    "news file",
    "screen clipping",
    "shell command",
    "suspend command",
    "terminal info library",
    "system configuration at run-time",

    save_bones_compat_buf, "and basic NetHack features"
};

struct win_info {
    const char *id, /* DEFAULT_WINDOW_SYS string */
        *name;      /* description, often same as id */
};

static struct win_info window_opts[] = {
    { "tty", "traditional tty-based graphics" },
    { 0, 0 }
};

static void
windowing_sanity()
{
    if (!window_opts[0].id) {
        Fprintf(stderr, "Configuration error: no windowing systems "
                        "(TTY_GRAPHICS, &c) enabled.\n");
        exit(EXIT_FAILURE);
    }

    {
        int i;

        for (i = 0; window_opts[i].id; ++i)
            if (!strcmp(window_opts[i].id, DEFAULT_WINDOW_SYS))
                break;
        if (!window_opts[i]
                 .id) { /* went through whole list without a match */
            Fprintf(stderr, "Configuration error: DEFAULT_WINDOW_SYS (%s)\n",
                    DEFAULT_WINDOW_SYS);
            Fprintf(stderr,
                    " does not match any enabled windowing system (%s%s).\n",
                    window_opts[0].id, window_opts[1].id ? ", &c" : "");
            exit(EXIT_FAILURE);
        }
    }
}

void
do_options()
{
    static const char indent[] = "    ";
    const char *str, *sep;
    char *word, buf[BUFSZ];
    int i, length, winsyscnt;

    windowing_sanity();

    filename[0] = '\0';
    Sprintf(eos(filename), DATA_TEMPLATE, OPTIONS_FILE);
    if (!(ofp = fopen(filename, WRTMODE))) {
        perror(filename);
        exit(EXIT_FAILURE);
    }

    build_savebones_compat_string();
    Fprintf(ofp,
            "\n    NetHack version %d.%d.%d\n",
            VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL);

    Fprintf(ofp, "\nOptions compiled into this edition:\n");
    length = COLNO + 1; /* force 1st item onto new line */
    for (i = 0; i < SIZE(build_opts); i++) {
        str = strcpy(buf, build_opts[i]);
        while (*str) {
            word = index(str, ' ');
            if (word)
                *word = '\0';
            if (length + strlen(str) > COLNO - 5)
                Fprintf(ofp, "\n%s", indent), length = strlen(indent);
            else
                Fprintf(ofp, " "), length++;
            Fprintf(ofp, "%s", str), length += strlen(str);
            str += strlen(str) + (word ? 1 : 0);
        }
        Fprintf(ofp, (i < SIZE(build_opts) - 1) ? "," : "."), length++;
    }

    winsyscnt = SIZE(window_opts) - 1;
    Fprintf(ofp, "\n\nSupported windowing system%s:\n",
            (winsyscnt > 1) ? "s" : "");
    length = COLNO + 1; /* force 1st item onto new line */
    for (i = 0; i < winsyscnt; i++) {
        str = window_opts[i].name;
        if (length + strlen(str) > COLNO - 5)
            Fprintf(ofp, "\n%s", indent), length = strlen(indent);
        else
            Fprintf(ofp, " "), length++;
        Fprintf(ofp, "%s", str), length += strlen(str);
        sep = (winsyscnt == 1)
                  ? "."
                  : (winsyscnt == 2)
                        ? ((i == 0) ? " and" : "")
                        : (i < winsyscnt - 2)
                              ? ","
                              : ((i == winsyscnt - 2) ? ", and" : "");
        Fprintf(ofp, "%s", sep), length += strlen(sep);
    }
    if (winsyscnt > 1)
        Fprintf(ofp, "\n%swith a default of %s.", indent, DEFAULT_WINDOW_SYS);
    Fprintf(ofp, "\n\n");

    Fclose(ofp);
    return;
}

/* routine to decide whether to discard something from data.base */
static boolean
d_filter(line)
char *line;
{
    if (*line == '#')
        return TRUE; /* ignore comment lines */
    return FALSE;
}

/*
 *
     New format (v3.1) of 'data' file which allows much faster lookups [pr]
"do not edit"           first record is a comment line
01234567                hexadecimal formatted offset to text area
name-a                  first name of interest
123,4                   offset to name's text, and number of lines for it
name-b                  next name of interest
name-c                  multiple names which share same description also
456,7                   share a single offset,count line
.                       sentinel to mark end of names
789,0                   dummy record containing offset, count of EOF
text-a                  4 lines of descriptive text for name-a
text-a                  at file position 0x01234567L + 123L
text-a
text-a
text-b/text-c           7 lines of text for names-b and -c
text-b/text-c           at fseek(0x01234567L + 456L)
...
 *
 */

void
do_data()
{
    char infile[60], tempfile[60];
    boolean ok;
    long txt_offset;
    int entry_cnt, line_cnt;
    char *line;

    Sprintf(tempfile, DATA_TEMPLATE, "database.tmp");
    filename[0] = '\0';
    Sprintf(eos(filename), DATA_TEMPLATE, DATA_FILE);
    Sprintf(infile, DATA_IN_TEMPLATE, DATA_FILE);
    Strcat(infile, ".base");
    if (!(ifp = fopen(infile, RDTMODE))) { /* data.base */
        perror(infile);
        exit(EXIT_FAILURE);
    }
    if (!(ofp = fopen(filename, WRTMODE))) { /* data */
        perror(filename);
        Fclose(ifp);
        exit(EXIT_FAILURE);
    }
    if (!(tfp = fopen(tempfile, WRTMODE))) { /* database.tmp */
        perror(tempfile);
        Fclose(ifp);
        Fclose(ofp);
        Unlink(filename);
        exit(EXIT_FAILURE);
    }

    /* output a dummy header record; we'll rewind and overwrite it later */
    Fprintf(ofp, "%s%08lx\n", Dont_Edit_Data, 0L);

    entry_cnt = line_cnt = 0;
    /* read through the input file and split it into two sections */
    while ((line = fgetline(ifp)) != 0) {
        if (d_filter(line)) {
            free(line);
            continue;
        }
        if (*line > ' ') { /* got an entry name */
            /* first finish previous entry */
            if (line_cnt)
                Fprintf(ofp, "%d\n", line_cnt), line_cnt = 0;
            /* output the entry name */
            (void) fputs(line, ofp);
            entry_cnt++;        /* update number of entries */
        } else if (entry_cnt) { /* got some descriptive text */
            /* update previous entry with current text offset */
            if (!line_cnt)
                Fprintf(ofp, "%ld,", ftell(tfp));
            /* save the text line in the scratch file */
            (void) fputs(line, tfp);
            line_cnt++; /* update line counter */
        }
        free(line);
    }
    /* output an end marker and then record the current position */
    if (line_cnt)
        Fprintf(ofp, "%d\n", line_cnt);
    Fprintf(ofp, ".\n%ld,%d\n", ftell(tfp), 0);
    txt_offset = ftell(ofp);
    Fclose(ifp); /* all done with original input file */

    /* reprocess the scratch file; 1st format an error msg, just in case */
    line = malloc(256);
    Sprintf(line, "rewind of \"%s\"", tempfile);
    if (rewind(tfp) != 0)
        goto dead_data;
    free(line);
    /* copy all lines of text from the scratch file into the output file */
    while ((line = fgetline(tfp)) != 0) {
        (void) fputs(line, ofp);
        free(line);
    }

    /* finished with scratch file */
    Fclose(tfp);
    Unlink(tempfile); /* remove it */

    /* update the first record of the output file; prepare error msg 1st */
    line = malloc(256);
    Sprintf(line, "rewind of \"%s\"", filename);
    ok = (rewind(ofp) == 0);
    if (ok) {
        Sprintf(line, "header rewrite of \"%s\"", filename);
        ok = (fprintf(ofp, "%s%08lx\n", Dont_Edit_Data,
                      (unsigned long) txt_offset) >= 0);
    }
    if (!ok) {
    dead_data:
        perror(line); /* report the problem */
        free(line);
        /* close and kill the aborted output file, then give up */
        Fclose(ofp);
        Unlink(filename);
        exit(EXIT_FAILURE);
    }
    free(line);

    /* all done */
    Fclose(ofp);

    return;
}

/* routine to decide whether to discard something from oracles.txt */
static boolean
h_filter(line)
char *line;
{
    static boolean skip = FALSE;
    char *tag;

    SpinCursor(3);

    if (*line == '#')
        return TRUE; /* ignore comment lines */

    tag = malloc(strlen(line));
    if (sscanf(line, "----- %s", tag) == 1) {
        skip = FALSE;
    } else if (skip && !strncmp(line, "-----", 5))
        skip = FALSE;
    free(tag);
    return skip;
}

static const char *special_oracle[] = {
    "\"...it is rather disconcerting to be confronted with the",
    "following theorem from [Baker, Gill, and Solovay, 1975].", "",
    "Theorem 7.18  There exist recursive languages A and B such that",
    "  (1)  P(A) == NP(A), and", "  (2)  P(B) != NP(B)", "",
    "This provides impressive evidence that the techniques that are",
    "currently available will not suffice for proving that P != NP or        "
    "  ",
    "that P == NP.\"  [Garey and Johnson, p. 185.]"
};

/*
   The oracle file consists of a "do not edit" comment, a decimal count N
   and set of N+1 hexadecimal fseek offsets, followed by N multiple-line
   records, separated by "---" lines.  The first oracle is a special case.
   The input data contains just those multi-line records, separated by
   "-----" lines.
 */

void
do_oracles()
{
    char infile[60], tempfile[60];
    boolean in_oracle, ok;
    long fpos;
    unsigned long txt_offset, offset;
    int oracle_cnt;
    register int i;
    char *line;

    Sprintf(tempfile, DATA_TEMPLATE, "oracles.tmp");
    filename[0] = '\0';
    Sprintf(eos(filename), DATA_TEMPLATE, ORACLE_FILE);
    Sprintf(infile, DATA_IN_TEMPLATE, ORACLE_FILE);
    Strcat(infile, ".txt");
    if (!(ifp = fopen(infile, RDTMODE))) {
        perror(infile);
        exit(EXIT_FAILURE);
    }
    if (!(ofp = fopen(filename, WRTMODE))) {
        perror(filename);
        Fclose(ifp);
        exit(EXIT_FAILURE);
    }
    if (!(tfp = fopen(tempfile, WRTMODE))) { /* oracles.tmp */
        perror(tempfile);
        Fclose(ifp);
        Fclose(ofp);
        Unlink(filename);
        exit(EXIT_FAILURE);
    }

    /* output a dummy header record; we'll rewind and overwrite it later */
    Fprintf(ofp, "%s%5d\n", Dont_Edit_Data, 0);

    /* handle special oracle; it must come first */
    (void) fputs("---\n", tfp);
    offset = (unsigned long) ftell(tfp);
    Fprintf(ofp, "%05lx\n", offset); /* start pos of special oracle */
    for (i = 0; i < SIZE(special_oracle); i++) {
        (void) fputs(xcrypt(special_oracle[i]), tfp);
        (void) fputc('\n', tfp);
    }
    SpinCursor(3);

    oracle_cnt = 1;
    (void) fputs("---\n", tfp);
    offset = (unsigned long) ftell(tfp);
    Fprintf(ofp, "%05lx\n", offset); /* start pos of first oracle */
    in_oracle = FALSE;

    while ((line = fgetline(ifp)) != 0) {
        SpinCursor(3);

        if (h_filter(line)) {
            free(line);
            continue;
        }
        if (!strncmp(line, "-----", 5)) {
            if (!in_oracle) {
                free(line);
                continue;
            }
            in_oracle = FALSE;
            oracle_cnt++;
            (void) fputs("---\n", tfp);
            offset = (unsigned long) ftell(tfp);
            Fprintf(ofp, "%05lx\n", offset); /* start pos of this oracle */
        } else {
            in_oracle = TRUE;
            (void) fputs(xcrypt(line), tfp);
        }
        free(line);
    }

    if (in_oracle) { /* need to terminate last oracle */
        oracle_cnt++;
        (void) fputs("---\n", tfp);
        offset = (unsigned long) ftell(tfp);
        Fprintf(ofp, "%05lx\n", offset); /* eof position */
    }

    /* record the current position */
    txt_offset = (unsigned long) ftell(ofp);
    Fclose(ifp); /* all done with original input file */

    /* reprocess the scratch file; 1st format an error msg, just in case */
    line = malloc(256);
    Sprintf(line, "rewind of \"%s\"", tempfile);
    if (rewind(tfp) != 0)
        goto dead_data;
    free(line);
    /* copy all lines of text from the scratch file into the output file */
    while ((line = fgetline(tfp)) != 0) {
        (void) fputs(line, ofp);
        free(line);
    }

    /* finished with scratch file */
    Fclose(tfp);
    Unlink(tempfile); /* remove it */

    /* update the first record of the output file; prepare error msg 1st */
    line = malloc(256);
    Sprintf(line, "rewind of \"%s\"", filename);
    ok = (rewind(ofp) == 0);
    if (ok) {
        Sprintf(line, "header rewrite of \"%s\"", filename);
        ok = (fprintf(ofp, "%s%5d\n", Dont_Edit_Data, oracle_cnt) >= 0);
    }
    if (ok) {
        Sprintf(line, "data rewrite of \"%s\"", filename);
        for (i = 0; i <= oracle_cnt; i++) {
            if (!(ok = (fflush(ofp) == 0)))
                break;
            if (!(ok = (fpos = ftell(ofp)) >= 0))
                break;
            if (!(ok = (fseek(ofp, fpos, SEEK_SET) >= 0)))
                break;
            if (!(ok = (fscanf(ofp, "%5lx", &offset) == 1)))
                break;
            if (!(ok = (fseek(ofp, fpos, SEEK_SET) >= 0)))
                break;
            offset += txt_offset;
            if (!(ok = (fprintf(ofp, "%05lx\n", offset) >= 0)))
                break;
        }
    }
    if (!ok) {
    dead_data:
        perror(line); /* report the problem */
        free(line);
        /* close and kill the aborted output file, then give up */
        Fclose(ofp);
        Unlink(filename);
        exit(EXIT_FAILURE);
    }
    free(line);

    /* all done */
    Fclose(ofp);

    return;
}

void
do_dungeon()
{
    int rcnt = 0;
    char *line;

    Sprintf(filename, DATA_IN_TEMPLATE, DGN_I_FILE);
    if (!(ifp = fopen(filename, RDTMODE))) {
        perror(filename);
        exit(EXIT_FAILURE);
    }
    filename[0] = '\0';
    Sprintf(eos(filename), DGN_TEMPLATE, DGN_O_FILE);
    if (!(ofp = fopen(filename, WRTMODE))) {
        perror(filename);
        exit(EXIT_FAILURE);
    }
    Fprintf(ofp, "%s", Dont_Edit_Data);

    tfp = getfp(DATA_TEMPLATE, "grep.tmp", WRTMODE);
    grep0(ifp, tfp);
    ifp = getfp(DATA_TEMPLATE, "grep.tmp", RDTMODE);

    while ((line = fgetline(ifp)) != 0) {
        SpinCursor(3);

        rcnt++;
        if (line[0] == '#') {
            free(line);
            continue; /* discard comments */
        }
        (void) fputs(line, ofp);
        free(line);
    }
    Fclose(ifp);
    Fclose(ofp);

    delete_file(DATA_TEMPLATE, "grep.tmp");
    return;
}

static boolean
ranged_attk(ptr) /* returns TRUE if monster can attack at range */
register struct permonst *ptr;
{
    register int i, j;
    register int atk_mask = (1 << AT_BREA) | (1 << AT_SPIT) | (1 << AT_GAZE);

    for (i = 0; i < NATTK; i++) {
        if ((j = ptr->XXmattk[i].type) >= AT_WEAP || (atk_mask & (1 << j)))
            return TRUE;
    }

    return FALSE;
}

/*      Start of Quest text file processing. */
#include "qtext.h"

static struct qthdr qt_hdr;
static struct msghdr msg_hdr[N_HDR];
static struct qtmsg *curr_msg;

static int qt_line;

static boolean in_msg;
#define NO_MSG 1 /* strlen of a null line returned by fgets() */

static boolean
qt_comment(s)
char *s;
{
    if (s[0] == '#')
        return  TRUE;
    return (boolean) (!in_msg && strlen(s) == NO_MSG);
}

static boolean
qt_control(s)
char *s;
{
    return (boolean) (s[0] == '%' && (s[1] == 'C' || s[1] == 'E'));
}

static int
get_hdr(code)
char *code;
{
    int i;

    for (i = 0; i < qt_hdr.n_hdr; i++)
        if (!strncmp(code, qt_hdr.id[i], LEN_HDR))
            return ++i;

    return 0;
}

static boolean
new_id(code)
char *code;
{
    if (qt_hdr.n_hdr >= N_HDR) {
        Fprintf(stderr, OUT_OF_HEADERS, qt_line);
        return FALSE;
    }

    strncpy(&qt_hdr.id[qt_hdr.n_hdr][0], code, LEN_HDR);
    msg_hdr[qt_hdr.n_hdr].n_msg = 0;
    qt_hdr.offset[qt_hdr.n_hdr++] = 0L;
    return TRUE;
}

static boolean
known_msg(num, id)
int num, id;
{
    int i;

    for (i = 0; i < msg_hdr[num].n_msg; i++)
        if (msg_hdr[num].qt_msg[i].msgnum == id)
            return TRUE;

    return FALSE;
}

static void
new_msg(s, num, id)
char *s;
int num, id;
{
    struct qtmsg *qt_msg;

    if (msg_hdr[num].n_msg >= N_MSG) {
        Fprintf(stderr, OUT_OF_MESSAGES, qt_line);
    } else {
        qt_msg = &(msg_hdr[num].qt_msg[msg_hdr[num].n_msg++]);
        qt_msg->msgnum = id;
        qt_msg->delivery = s[2];
        qt_msg->offset = qt_msg->size = qt_msg->summary_size = 0L;

        curr_msg = qt_msg;
    }
}

/* check %E record for "[summary text]" that nethack can stuff into the
   message history buffer when delivering text via window instead of pline */
static char *
valid_qt_summary(s, parsing)
char *s;         /* end record: "%E" optionally followed by " [summary]" */
boolean parsing; /* curr_msg is valid iff this is True */
{
    static char summary[BUFSZ];
    char *p;

    if (*s != '%' || *(s + 1) != 'E')
        return (char *) 0;
    if ((p = index(s, '[')) == 0)
        return (char *) 0;
    /* note: opening '[' and closing ']' will be retained in the output;
       anything after ']' will be discarded by putting a newline there */
    Strcpy(summary, p);

    /* have an opening bracket; summary[] holds it and all text that follows
     */
    p = eos(summary);
    /* find closing bracket */
    while (p > summary && *(p - 1) != ']')
        --p;

    if (p == summary) {
        /* we backed up all the way to the start without finding a bracket */
        if (parsing) /* malformed summary */
            Fprintf(stderr, MAL_SUM, qt_line);
    } else if (p == summary + 1) {
        ;    /* ignore empty [] */
    } else { /* got something */
             /* p points one spot past ']', usually to '\n';
                we need to include the \n as part of the size */
        if (parsing) {
            /* during the writing pass we won't be able to recheck
               delivery, so any useless summary for a pline mode
               message has to be carried along to the output file */
            if (curr_msg->delivery == 'p')
                Fprintf(stderr, DUMB_SUM, qt_line);
            /* +1 is for terminating newline */
            curr_msg->summary_size = (long) (p - summary) + 1L;
        } else {
            /* caller is writing rather than just parsing;
               force newline after the closing bracket */
            Strcpy(p, "\n");
        }
        return summary;
    }
    return (char *) 0;
}

static void
do_qt_control(s)
char *s;
{
    char code[BUFSZ];
    int num, id = 0;

    if (!index(s, '\n'))
        Fprintf(stderr, CTRL_TRUNC, qt_line);

    switch (s[1]) {
    case 'C':
        if (in_msg) {
            Fprintf(stderr, CREC_IN_MSG, qt_line);
            break;
        } else {
            in_msg = TRUE;
            if (sscanf(&s[4], "%s %5d", code, &id) != 2) {
                Fprintf(stderr, UNREC_CREC, qt_line);
                break;
            }
            num = get_hdr(code);
            if (!num && !new_id(code))
                break;
            num = get_hdr(code) - 1;
            if (known_msg(num, id))
                Fprintf(stderr, DUP_MSG, qt_line);
            else
                new_msg(s, num, id);
        }
        break;

    case 'E':
        if (!in_msg) {
            Fprintf(stderr, END_NOT_IN_MSG, qt_line);
        } else {
            /* sets curr_msg->summary_size if applicable */
            (void) valid_qt_summary(s, TRUE);
            in_msg = FALSE;
        }
        break;

    default:
        Fprintf(stderr, UNREC_CREC, qt_line);
        break;
    }
}

static void
do_qt_text(s)
char *s;
{
    if (!in_msg) {
        Fprintf(stderr, TEXT_NOT_IN_MSG, qt_line);
    } else if (!index(s, '\n')) {
        Fprintf(stderr, TEXT_TRUNC, qt_line);
    }

    curr_msg->size += strlen(s);
    return;
}

static void
adjust_qt_hdrs()
{
    int i, j;
    long count = 0L, hdr_offset = sizeof(int)
                                  + (sizeof(char) * LEN_HDR + sizeof(long))
                                        * qt_hdr.n_hdr;

    for (i = 0; i < qt_hdr.n_hdr; i++) {
        qt_hdr.offset[i] = hdr_offset;
        hdr_offset += sizeof(int) + sizeof(struct qtmsg) * msg_hdr[i].n_msg;
    }

    for (i = 0; i < qt_hdr.n_hdr; i++)
        for (j = 0; j < msg_hdr[i].n_msg; j++) {
            msg_hdr[i].qt_msg[j].offset = hdr_offset + count;
            count +=
                msg_hdr[i].qt_msg[j].size + msg_hdr[i].qt_msg[j].summary_size;
        }
    return;
}

static void
put_qt_hdrs()
{
    int i;

    /*
     *  The main header record.
     */
    if (debug)
        Fprintf(stderr, "%ld: header info.\n", ftell(ofp));
    (void) fwrite((genericptr_t) & (qt_hdr.n_hdr), sizeof(int), 1, ofp);
    (void) fwrite((genericptr_t) & (qt_hdr.id[0][0]), sizeof(char) * LEN_HDR,
                  qt_hdr.n_hdr, ofp);
    (void) fwrite((genericptr_t) & (qt_hdr.offset[0]), sizeof(long),
                  qt_hdr.n_hdr, ofp);
    if (debug) {
        for (i = 0; i < qt_hdr.n_hdr; i++)
            Fprintf(stderr, "%s @ %ld, ", qt_hdr.id[i], qt_hdr.offset[i]);
        Fprintf(stderr, "\n");
    }

    /*
     *  The individual class headers.
     */
    for (i = 0; i < qt_hdr.n_hdr; i++) {
        if (debug)
            Fprintf(stderr, "%ld: %s header info.\n", ftell(ofp),
                    qt_hdr.id[i]);
        (void) fwrite((genericptr_t) & (msg_hdr[i].n_msg), sizeof(int), 1,
                      ofp);
        (void) fwrite((genericptr_t) & (msg_hdr[i].qt_msg[0]),
                      sizeof(struct qtmsg), msg_hdr[i].n_msg, ofp);
        if (debug) {
            int j;

            for (j = 0; j < msg_hdr[i].n_msg; j++) {
                Fprintf(stderr, "msg %d @ %ld (%ld)",
                        msg_hdr[i].qt_msg[j].msgnum,
                        msg_hdr[i].qt_msg[j].offset,
                        msg_hdr[i].qt_msg[j].size);
                if (msg_hdr[i].qt_msg[j].summary_size)
                    Fprintf(stderr, " [%ld]",
                            msg_hdr[i].qt_msg[j].summary_size);
                Fprintf(stderr, "\n");
            }
        }
    }
}

void
do_questtxt()
{
    char *line;

    Sprintf(filename, DATA_IN_TEMPLATE, QTXT_I_FILE);
    if (!(ifp = fopen(filename, RDTMODE))) {
        perror(filename);
        exit(EXIT_FAILURE);
    }

    filename[0] = '\0';
    Sprintf(eos(filename), DATA_TEMPLATE, QTXT_O_FILE);
    if (!(ofp = fopen(filename, WRBMODE))) {
        perror(filename);
        Fclose(ifp);
        exit(EXIT_FAILURE);
    }

    qt_hdr.n_hdr = 0;
    qt_line = 0;
    in_msg = FALSE;

    while ((line = fgetline(ifp)) != 0) {
        SpinCursor(3);

        qt_line++;
        if (qt_control(line))
            do_qt_control(line);
        else if (qt_comment(line)) {
            free(line);
            continue;
        } else
            do_qt_text(line);
        free(line);
    }

    (void) rewind(ifp);
    in_msg = FALSE;
    adjust_qt_hdrs();
    put_qt_hdrs();
    while ((line = fgetline(ifp)) != 0) {
        if (qt_control(line)) {
            char *summary_p = 0;

            in_msg = (line[1] == 'C');
            if (!in_msg)
                summary_p = valid_qt_summary(line, FALSE);
            /* don't write anything unless we've got a summary */
            if (!summary_p) {
                free(line);
                continue;
            }
            /* we have summary text; replace raw %E record with it */
            Strcpy(line, summary_p); /* (guaranteed to fit) */
        } else if (qt_comment(line)) {
            free(line);
            continue;
        }
        if (debug)
            Fprintf(stderr, "%ld: %s", ftell(stdout), line);
        (void) fputs(xcrypt(line), ofp);
        free(line);
    }
    Fclose(ifp);
    Fclose(ofp);
    return;
}

static char temp[32];

static char *limit(name, pref) /* limit a name to 30 characters length */
char *name;
int pref;
{
    (void) strncpy(temp, name, pref ? 26 : 30);
    temp[pref ? 26 : 30] = 0;
    return temp;
}

/* Read one line from input, up to and including the next newline
 * character. Returns a pointer to the heap-allocated string, or a
 * null pointer if no characters were read.
 */
static char *
fgetline(fd)
FILE *fd;
{
    static const int inc = 256;
    int len = inc;
    char *c = malloc(len), *ret;

    for (;;) {
        ret = fgets(c + len - inc, inc, fd);
        if (!ret) {
            free(c);
            c = NULL;
            break;
        } else if (index(c, '\n')) {
            /* normal case: we have a full line */
            break;
        }
        len += inc;
        c = realloc(c, len);
    }
    return c;
}

static char *
tmpdup(str)
const char *str;
{
    static char buf[128];

    if (!str)
        return (char *) 0;
    (void) strncpy(buf, str, 127);
    return buf;
}

static char *
eos(str)
char *str;
{
    while (*str)
        str++;
    return str;
}

/*makedefs.c*/
